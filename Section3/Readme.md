# 데이터 카테고리/다양한 종류의 데이터 이해하기
### 어플리케이션이 실행되는 동안 생성된 임시 데이터
예를 들어 웹 사이트의 경우 사용자가 입력폼에 무언가를 입력할 수 있고 그런 다음 우리는 그 데이터를 가져와 서버에서 실행 중인 컨테이너에서 처리하는데 
이때 입력된 그 사용자 데이터가 임시 데이터이다.    
코드의 변수에 저장될 수 있기에 결국 메모리에만 저장되거나, 데이터베이스나 파일에 저장될 수도 있다.    
임시 데이터는 읽기와 쓰기가 가능하기에 이미지가 아닌 컨테이너에 저장된다.     

<img width="1059" alt="스크린샷 2022-05-30 오후 1 11 33" src="https://user-images.githubusercontent.com/63203480/170915743-63fb047f-cc3f-4dd6-9366-b9b9843a94c7.png">

이미지 위에 도커에 추가된 컨테이너 레이어는 기본적으로 로직이라 할 수 있는데, 이미지와 이미지의 파일시스템을 인식하고, 복사하지 않고 파일 시스템을 미러링하는 로직이다.    
도커는 실제로 read-write 액세스 권한을 가지며 파일 시스템을 조작할 수 있다. 이미지에서 변경하지 않으며, 컨테이너 레이어에서 변경한다.   
도커는 컨테이너의 변경 사항을 추적하고, 이미지의 파일 시스템을 가져와서 최종 파일 시스템을 파싱해서 Read-Write 레이어에 저장된 변경 사항과 결합시킨다.    

컨테이너에게 정보를 저장하라고 하면, 저장하고 파일이 무엇이든 간에 이 Read-Write 레이어에 저장하거나 그 Read-Write 레이어의 도움을 받아 저장한다.    
이러한 저장된 정보들은 컨테이너에만 있지 로컬 파일 시스템, 로컬 머신에 없고, 이미지에도 없다.

### 영구 어플리케이션 데이터
일반적인 어플리케이션은 사용자의 데이터를 받아 파일에 저장하거나, 일반적인 데이터베이스에 저장한다. 그리고 그 데이터는 지속되어야 합니다.    
실행중인 컨테이너에서는 그 데이터를 가져와 생성한다. 따라서 컨테이너에서 실행 중인 어플리케이션 내의 데이터는 저장되어야만 한다.
왜냐하면 컨테이너가 중지되거나 재실행되어도 데이터는 그대로 있어야 하기 때문이다. 또한 컨테이너가 삭제되어도 데이터는 보존되어야 한다.   

새로운 버전의 어플리케이션을 배포하게 된다면 어쨌든 컨테이너를 중지시키고 새 버전을 배포하게 된다. 하지만 그 과정에서 어플리케이션 데이터가 손실되서는 안된다.   
컨테이너를 중지하게 되면 임시 데이터, 영구 데이터 등 손실되지 않아야 하는 데이터가 존재한다.   
따라서 데이터를 컨테이너에 저장하지만 **볼륨의 도움**을 받게 된다.

볼륨은 도커에 적용된 핵심적인 개념중 하나이다. 

# 데모 앱 구축 & 이해하기
```Dockerfile``` 에서 우리 로컬 폴더를 이미지에 복사하고 컨테이너는 그 이미지를 기반으로 실행되기 때문에 실행 중인 어플리케이션에 파일을 저장한다고 해도 로컬에는 저장되지 않는다.    
이것을 통해 알 수 있는 것은 로컬 폴더를 기반으로 하는 자체 파일 시스템이 있다는 것을 의미한다. 하지만 복사 된 이후에는 로컬과 실행 중인 이미지 내부 파일 시스템 사이에 연결은 없다.

# 문제 이해하기
컨테이너를 중지하고 재실행한다면 기존 존재하던 컨테이너의 파일이 손실되지 않는다. 하지만 컨테이너를 삭제한다면 기존 컨테이너에서 생성되어 저장된 모든 데이터는 손실되게 된다.   
컨테이너는 파일을 생성할 때, 이미지에 쓰지 않고 컨테이너 레이어에 저장한다.  

즉, 동일한 이미지에 기반한 다수의 컨테이너가 서로에게 완전히 격리된다는 것이 바로 도커의 핵심 개념이다.

그렇다면 위와 같이 데이터가 손실되는 것을 해결할 수 있는 방법은 무엇일까? 그것은 바로 **볼륨**이라는 도커 내장 기능이다.

# 볼륨
볼륨은 데이터를 유지하는 것을 도우며 데이터의 손실을 해결하는데 도움이 된다.   

볼륨이란 컨테이너 외부의 특정 폴더에 연결된 Docker 컨테이너 내부의 폴더, 파일이다. 볼륨은 호스트 머신의 폴더이다. 컨테이너나 이미지에 있는 것이 아니다.  
호스트 컴퓨터에 장착된 하드 드라이브에 존재하여 사용가능하거나, 컨테이너로 매칭되는 것을 의미한다.   
즉, 볼륨은 도커가 인식하는 호스트 머신인 로컬 컴퓨터에 있는 폴더로 도커 컨테이너 내부의 폴더에 매핑된다.   

볼륨은 컨테이너 내부의 폴더와 호스트 머신 상의 컨테이너 외부 폴더에 연결할 수 있다. 그리고 두 폴더의 변경 사항은 다른 폴더에 반영된다.
따라서 호스트 머신에 파일을 추가하면 컨테이너 내부에서 접근할 수 있고, 컨테이너가 매핑된 경로에 파일을 추가하면 컨테이너 외부, 즉 호스트 머신에서도 사용할 수 있다.

볼륨은 컨테이너가 종료된 경우에도 지속되며 계속 존재한다. 컨테이너에 볼륨을 추가하는 경우 해당 볼륨은 제거되지 않으며 컨테이너가 제거되어도 해당 볼륨이 유지되므로 데이터가 유지된다.
그리고 컨테이너는 볼륨에 데이터를 읽고 쓸 수 있다. 컨테이너 외부에서 액세스하려는 폴더 또는 단순히 컨테이너 종료 및 컨테이너 제거 후에도 생존해야하는 데이터에 사용할 수 있다.

# 볼륨을 컨테이너에 추가 
볼륨을 사용하기 위한 첫 번째 방법은 ```Dockerfile``` 에서 ```VOLUME``` 명령을 추가하는 것이다.   
컨테이너의 외부 폴더에 매칭되어질 내 컨테이너 내부 위치를 지정해줘야 한다. 즉, 데이터가 생존할 위치를 지정하는 것이다.
```dockerfile
WORKDIR /app
#...
VOLUME ['/app/feedback']
#...
```
볼륨의 이름을 지정하지 않는다면 이미지나 컨테이너와 같이 자동으로 도커에서 지정해준다.

# Named 볼륨으로 구조하기!
도커에는 실제로 여러 가지의 외부 데이터 저장 매커니즘이 있다. 그것은 **볼륨과 바인드 마운트** 이다.   
실제로는 두 가지 타입(Anonymous/Named Volumes)의 볼륨이 있고, 둘 다 고유한 목적과 사용예가 있다.   

도커 파일의 ```VOLUME ['/app/feedback']``` 명령은 해당 이미지에 익명의(Anonymous) 볼륨을 추가하고 그 이미지를 기반으로 실행되는 컨테이너에 데이터를 추가한다. 

### 익명의 볼륨
```docker volume ls``` 명령을 통해 도커가 현재 관리 중인 모든 볼륨을 리스팅한다. 
익명의 볼륨일 경우 **컨테이너가 중지되었을 때, 해당하는 익명 볼륨이 리스트에서 조회되지 않는다**.    
즉, 익명 볼륨은 컨테이너가 존재하는 동안에만 실제로 존재한다는 것이다.

컨테이너에 정의된 경로는 생성된 어떤 볼륨에 매핑된다. 그래서 호스트 머신 상의 생성된 경로로 연결된다.    
예를 들어 ```Dockerfile``` 의 ```VOLUME ['/app/feedback']``` 경로는 호스트 머신의 어떤 폴더에 매핑된다. 
하지만 우리는 그 경로를 알지 못한다. 왜냐하면 도커에서 관리하기 때문이다. 우리의 컴퓨터에 존재하며, 우리가 접근할 수 없도록 되어있다.

만약 컨테이너가 중지되었을 때 볼륨만 삭제되지 않는다면 이론적으로 좋은 개념이다. 이것은 Named 볼륨을 사용하면 컨테이너가 종료된 후에도 볼륨이 유지될 수 있다. 
즉, 하드 드라이브의 폴더가 그대로 유지된다. 따라서 그 이후에 새 컨테이너를 시작하면 볼륨과 폴더가 복구되어 해당 폴더에 저장된 모든 데이터를 계속 사용할 수 있다.

### 명명(Named) 볼륨
따라서 Named 볼륨은 영구적이어야 하는 데이터나, 편집하거나 직접 볼 필요가 없는 중요한 데이터에 적합하다.   

도커 파일 내부에는 Named 볼륨을 생성할 수 없다. 대신 **컨테이너를 실행할 때, 명령을 추가해서 Named 볼륨을 생성**해야 한다.  
```
// ex) $ docker run -v [원하는 이름]:[컨테이너 파일 시스템 내부 경로]
$ docker run -v feedback:/app/feedback
```
컨테이너 내부의 ```/app/feedback``` 폴더에 연결하지만 해당 볼륨은 우리가 선택한 ```feedback``` 이름으로 저장된다.   
Named 볼륨은 컨테이너가 종료될 때 도커에 의해서 삭제되지 않는다는 것이다. 또한 Named 볼륨은 하나의 컨테이너에만 연결되지는 않는다. 

만약 사용하지 않는 볼륨이 있을 경우 ```$ docker volume rm VOL_NAME``` 또는 ```$ docker volume prune``` 명령을 통해 볼륨을 삭제할 수 있다.    
익명 볼륨은 ```Dockerfile``` 에서 지정해주고, Named 볼륨은 명령을 통해 지정하는 것이다.

## 바인드 마운트(Bind Mounts)
우리가 어플리케이션의 소스코드를 수정했을 때, 이미지를 다시 빌드하지 않는 한 이러한 변경 사항은 실행 중인 컨테이너에 반영되지 않는다.
하지만 어플리케이션이 실행되고 있는 중에 도커를 사용한다면 이러한 변경 사항이 반영되는 것은 매우 중요하다. 
그렇지 않다면 변경사항이 있을 때마다 매번 전체 이미지를 리빌드하고 컨테이너를 재실행하여 하기 때문이다.    
이러한 점을 바로 **바인드 마운트**가 도와준다. 즉, 컨테이너에 실시간 데이터를 제공하고 이미지를 리빌딩할 필요가 없다. 

호스트 머신의 파일 시스템 상의 볼륨이 어디에 있는지 우리가 알 수 있는 방법이 없다. 하지만 바인트 마운트의 경우 볼륨의 위치를 알고 있다.     
Named 볼륨은 영구 데이터에 도움이 되지만, 편집이 불가능하다. 왜냐하면 호스트 머신의 어디에 저장되어 있는지 모르기 때문이다.   

바인드 마운트를 추가하기 위해서는 Dockerfile 내부에서 하는 것이 아니다.
실제로 이미지가 아니라 실행하는 컨테이너에만 적용되기 때문에 이미지에는 영향을 주지않고 컨테이너에만 영향을 준다.

바인드 마운트는 컨테이너를 실행할 때 ```-v``` 옵션을 통해 추가한다.     
```
//ex) $ docker -v [현재 프로젝트 절대경로]:[컨테이너 앱 경로] ...
$ docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback -v /Users/choidoorim/Desktop/Docker 강의/Source/data-volumes-02-added-dockerfile:/app feedback-node:volume      
```

경로에 특수 문자나 공백이 포함된 경우 깨지지 않도록 ```"``` 콜론을 추가해줘도 된다.
```
"/Users/choidoorim/Desktop/Docker 강의/Source/data-volumes-02-added-dockerfile:/app"
```

바인딩 마운트로 **공유 중인 폴더에 도커가 액세스할 수 있는지 반드시 확인**해야 한다.
도커의 ```Preferences(기본설정) -> Resources -> FILE SHARING``` 에서 공유 중인 폴더의 상위 폴더가 표시되어야 한다.

<img width="850" alt="스크린샷 2022-06-03 오후 9 35 26" src="https://user-images.githubusercontent.com/63203480/171854836-6cfc9d17-ed15-44aa-9c77-4b7ec6f13207.png">

만약 없다면 공유 가능 리소스로 추가하는 것이 중요하다.

## 다른 볼륨 결합 & 병합하기
컨테이너 내부의 어떤 폴더가 호스트 머신의 폴더에 마운트되거나 연결된다.   

이미 컨테이너 내부에 파일이 있다고 가정해보자. 이러한 경우에 외부 볼륨에 해당 파일이 존재한다. 
왜냐하면 새 파일을 작성하게 된다면 호스트 머신의 폴더에도 추가되기 때문이다.

만약 컨테이너 내부에 파일이 없고 로컬 호스트 머신에는 파일이 존재한다고 가정해보자. 
이러한 경우 로컬 호스트 머신에 파일을 컨테이너 내부에서도 사용할 수 있지만 2 가지의 문제가 발생한다.

기본적으로 도커는 호스트 폴더들을 덮어씌우지 않는다. 왜냐하면 그렇게 했다가 컴퓨터 내부의 중요한 파일들을 실수로 삭제하는 경우가 발생할 수 있기 때문이다.   
하지만 반대로 로컬 호스트 폴더와 그 안에 있는 것들이 도커 컨테이너에 있는 내용을 덮어쓴다.
이러한 이유때문에 만약 로컬에 ```node module``` 폴더가 없다면 도커 컨테이너의 ```node module``` 폴더는 삭제된다.      
이것을 방지하기 위해서는 도커에게 외부에서 덮어씌우면 안되는 것이 있다고 알리는 ```-v [도커 컨테이너 내부의 폴더 경로]``` 명령을 추가해야 한다. 

```
$ docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback -v "/Users/choidoorim/Desktop/Docker 강의/Source/data-volumes-02-added-dockerfile:/app" -v /app/node_modules feedback-node:volume
```
이렇게 한다면 결과적으로 이미지를 리빌드하지 않아도 변경된 사항을 바로 반영할 수 있다. 그 이유는 바인드 마운트를 추가해줬기 때문이다.

다른 방법도 존재하는데 도커 파일에 아래 명령을 추가하면 된다. 하지만 도커파일에 추가하게 된다면 이미지를 다시 빌드해야 된다는 문제 때문에 컨테이너 실행 시 옵션으로 추가하는 것이 좋다.
```dockerfile
VOLUME ['/app/node_modules']
```


# 컨테이너에서 Nodemon 사용하기
기존에는 Node 서버 코드의 변경사항을 반영하기 위해서는 서버를 중지 후 재시작을 해야했다.
하지만 ```nodemon``` 패키지를 사용한다면 코드의 변경사항이 있을 경우 자동으로 서버를 재실행해준다.
물론 ```nodemon``` 은 내부적으로 node 를 사용하긴 한다.

# 볼륨 & 바인딩 마운트: 요약
```$ docker run``` 명령의 ```-v``` 옵션을 사용하는 3 가지 방식이 있다.

1. 첫 번째는 Anonymous(익명의) 볼륨을 생성한다. 이름을 짓지 않기 때문이다: ```docker run -v /app/data ...```
2. 두 번째는 Named(명명된) 볼륨을 생성한다: ```docker run -v data:/app/data ...```
3. 세 번째는 실제로 호스트 머신의 폴더를 가리키는 절대 경로이다. 이것은 바로 바인드 마운트이다: ```docker run -v /path/code:/app/code```

### Anonymous Volume
컨테이너에 연결된 볼륨을 생성한다.  
**컨테이너가 제거된다면 볼륨도 제거**된다는 특징이 있다. 컨테이너를 종료하고 다시 시작해도 컨테이너가 제거되면 익명 볼륨 역시 제거된다.    
해당 볼륨을 사용하면 컨테이너 간에 데이터를 공유할 수 없다.    
데이터를 저장하는 목적에 적합하지 않다.

Anonymous 볼륨은 시간을 절약할 수 있다는 특장점이 있다. 또한 호스트 머신에 폴더를 생성한다.
물론 컨테이너가 제거되면 그 폴더도 제거된다. 컨테이너가 실행되는 동안에는 존재한다.
이는 도커가 컨테이너 내부에 모든 데이터들을 저장할 필요가 없고, Read-Write 계층 내부의 모든 데이터를 관리할 필요는 없다는 것을 의미한다.    
하지만 특정 데이터를 호스트 머신 파일 시스템에 아웃소싱(제 3자에게 위탁하는 것)할 수 있다.

이는 성능과 효율성에도 도움이 된다.

### Named Volume
```Dockerfile``` 에서 생성할 수 없다. 대신 컨테이너 실행 시에 ```-v``` 옵션을 추가해서 생성한다.    
콜론 앞에 이름을 지정하기 때문에 Named Volume 이라고 하는 것이다.

Named Volume 의 장점은 특정 컨테이너에 연결되어 있지 않고 일반적으로 생성된다는 것이다.   
컨테이너를 종료하거나 제거해도 살아남는다. 볼륨을 삭제하기 위해서는 도커 CLI 의 내장 명령으로 해야한다.

계속해서 살아남기 때문에 그를 사용하여 여러 개의 컨테이너 간에 데이터를 공유할 수 있다.
즉, 다수의 다양한 컨테이너에 동일하게 Named Volume 하나를 마운트할 수 있다.

### Bind Mounts
우리는 호스트 머신에 데이터가 저장되는 위치를 알고 있다. 바인트 마운트 또한 하나의 특정 컨테이너에 국한되지 않는다.
다수의 컨테이너에 연결할 수 있으며 컨테이너 종료 및 제거 후에도 유지된다.

바인드 마운트의 데이터를 지우려면 실제로 호스트 머신에서 삭제해야 한다.
즉, 호스트 모든 폴더, 파일들을 삭제해야 컨테이너의 모든 데이터를 제거할 수 있다는 것이다.  
**도커 CLI 를 통해서는 삭제할 수 없다**. 바인드 마운트란 결국 우리 개인 시스템에 있는 폴더인 것이다.

컨테이너 간의 공유도 가능하다. 그리고 재시작을 통해 동일한 컨테이너 중에서 재사용할 수도 있다.

# 읽기 전용 볼륨 살펴보기
바인드 마운트는 호스트에서 소스를 변경하고 그에 대한 변경사항을 컨테이너 내부에서 자동적으로 사용할 수 있다. 
즉, 컨테이너는 로컬에 있는 파일들을 변경할 수 없다는 것이다. 우리가 파일을 변경할 수 있는 곳은 호스트 머신 파일 시스템이지 컨테이너 내부가 아니라는 것이다.

기본적으로 볼륨은 Read-Write 이며, 이는 컨테이너가 볼륨에서 데이터를 읽고 쓸 수 있음을 의미한다. 
하지만 컨테이너는 일고, 쓰기를 지정할 수 있는데 내부 경로 뒤에 콜론을 추가한 다음 그 뒤에 **read only 를 의미하는 'ro' 를 추가**한다.
```
$ docker run ... -v "/User/...:/app:ro"
```
이렇게 하면 도커가 이제 해당 폴더나 그 하위 폴더에 Write 를 할 수 없게 된다. 이것은 우리 호스트에게 영향을 미치지는 않는다.
컨테이너와 컨테이너에서 실행되는 어플리케이션에만 영향을 미친다.

만약 호스트 내부에 쓰기를 해야하는 폴더가 있다면 해당 폴더를 Anonymous Volume 으로 생성하여 임시 데이터로 쓸 수 있게 해주면 된다.
그렇게하여 내부적으로 좀 더 효율적일 수 있을 것이다.
```
$ docker run ... -v "/User/...:/app:ro" -v /app/temp ...
```

# Docker 볼륨 관리하기
컨테이너를 실행할 때 ```-v``` 옵션을 사용하면 도커는 볼륨을 생성한다. 이것은 호스트 시스템 어딘가에 자동으로 폴더를 생성한다는 의미이다.

```$ docker volume ls``` 명령을 통해 현재 활성화 중인 볼륨을 모두 리스팅한다.    
바인드 마운트는 리스트에 표시되지 않는다. 왜냐하면 바인드 마운트는 도커에 의해 관리되는 볼륨이 아니기 때문이다.
바인드 마운트는 우리의 로컬 폴더를 컨테이너 내부의 폴더에 바인딩하는 것이다.

도커에 의해 볼륨이 관리된다는 것은 컨테이너를 실행할 때 볼륨이 존재하지 않다면 생성한다는 의미이기도 하다.       
```$ docker volume create [Options] [Volume]``` 명령을 통해 자체적인 볼륨을 생성하여 사용할 수 있다.
하지만 자동으로 도커가 생성해주기에 필요하지 않다면 굳이 수동으로 생성할 필요는 없다.

```$ docker volume inspect [Volume]``` 명령을 통해 볼륨에 대한 몇 가지 정보를 확인할 수 있다.  
읽기전용 볼륨일 경우 ```Option``` 컬럼을 통해 확인이 가능하다.

```$ docker volume rm [Volume]``` 명령을 사용하면 볼륨을 제거할 수 있다. 하지만 현재 사용중인 볼륨이 있다면 에러가 발생하게 된다.
볼륨이 연관된 실행 중인 컨테이너가 있다면 중지한 뒤에 삭제해야 한다. 

# "COPY" 사용 vs 바인드 마운트 사용
바인드 마운트를 사용한다면 Dockerfile 의 COPY 명령을 제거해도 된다. 
하지만 바인드 마운트에 대해 잊으면 안되는 중요한 사항이 있다. 

```$ docker run``` 명령은 개발 중에 사용하는 명령이다. 개발 중에 바인드 마운트를 통해 코드의 변경 사항을 실행 중인 컨테이너에 즉시 반영한다.
개발을 마친 뒤에는 실제로 이 컨테이너를 가져와 서버에 넣는다.      
데이터가 유지되기 위해서 볼륨을 사용할 수 있지만 바인드 마운트를 사용하지 않는다.
왜냐하면 컨테이너가 서버 상의 제품 상태로 실행 중이라면 실행되는 동안 실시간으로 업데이트 되는 연결된 소스 코드가 없기에 그렇게 하면 안된다.

Production 환경에서는 항상 코드의 스냅샷을 가지고 있어야 한다. 그것이 Dockerfile 에 COPY 명령을 유지하는 이유이다.
따라서 코드의 스냅샷을 지닌 이미지는 Production 환경에서 컨테이너를 가동하는데 사용할 수 있다.

개발 중에 바인드 마운트를 사용하는 것도 작동하기에 괜찮지만 Production 용 스냅샷 컨테이너를 생성하는 옵션은 반드시 필요하다.

# dockerignore 파일 사용하기
```COPY . .``` 명령은 Dockerfile 이 있는 폴더의 모든 항목을 복사한다. ```.dockerignore``` 파일을 추가하면 복사하는 것을 제한할 수 있다.
즉, COPY 명령으로 복사해서는 안 되는 폴더와 파일을 지정할 수 있다.

예를 들면 NodeJS 의 node_module 은 복사되면 안된다. 왜냐하면 로컬에 존재하는 node_modules 폴더가 오래되었을 수도 있고, 이미지 내부에 추가한 중요한 종속성이 누락될 수도 있다.
또는 최신버전이라도 복사 과정이 오래 걸릴 수도 있다. 그래서 ```.dockerignore``` 파일에 추가하는 것이다. node_modules 폴더의 내용이 이미지로 복사되지 않도록 하는 것이다.

# 환경 변수 & ".env" 파일 작업
도커는 빌드 타임 인수와 런타임 환경 변수를 지원한다.

인수(Argument) 를 사용하면 Dockerfile 에서 특정 Dockerfile 명령으로 다른 값을 추출하는데 사용할 수 있는 유연한 데이터 비트, 
즉 ```docker build``` 를 실행할 때 ```--build-arg``` 옵션과 함께 제공되는 인수를 기반으로 변수를 설정할 수 있다.       

환경변수는 인수처럼 Dockerfile 내부에서 사용할 수 있다. 반면 인수는 실행 중인 어플리케이션의 전체 어플리케이션 코드에서 사용할 수 있다.
Dockerfile 내부의 ENV 옵션으로 설정하여 해당 환경 변수가 존재한다고 Docker 에 알린 다음, ```docker run``` 에서 ```--env``` 옵션을 사용하여 구체적인 값을 제공한다.

인수와 환경 변수를 통해 보다 유연한 이미지와 컨테이너를 만들 수 있다. 컨테이너와 이미지에 모든 것을 **하드코딩할 필요가 없기 때문**이다.
대신 이미지를 빌드할 때 또는 컨테이너를 실행할 때만 동적으로 설정할 수 있다.

```dockerfile
# ...
# ENV [환경변수명] [디폴트 값]
ENV PORT 80 
```

그리고 지정된 환경 변수를 ```$``` 표시를 통해 Dockerfile 에서 변수처럼 사용할 수 있다.
```dockerfile
ENV PORT 80 

EXPOSE $PORT
```

Dockerfile 이 아닌 명령을 통해 ENV 를 설정할 수 있다. 
```docker run``` 명령 시에 ```--env``` 또는 ```-e``` 옵션에 키와 쌍으로 값을 추가하면 된다.

```
$ docker run ... --env PORT=8000 -e NODE_ENV=local ...
```

원한다면 환경 변수가 포함된 파일을 지정할 수도 있다.
```dotenv
# .env 파일
PORT=8000
```

```.env``` 파일이 있다면 컨테이너를 실행하기 위해 여기에 환경 변수를 추가하는 ```--env``` 또는 ```-e``` 대신에 ```--env-file``` 옵션을 사용해서 
환경 변수가 포함된 파일을 지정한다. 현재 터미널에서 있는 폴더의 위치를 기반으로 지정해야 한다. 
```
$ docker run --env-file ./env
```
그러면 파일에서 값을 읽어드린다.

인수와 환경 변수는 서로 다른 모드, 다른 구성에서 하나의 동일한 이미지를 기반으로 하나의 동일한 컨테이너를 실행하는데 도움이 된다.

# 빌드 인수(ARG) 사용하기
이미지를 빌드할 때, 다른 값을 끼어넣을 수 있다. 즉, 다른 디폴트 값으로 여러 번 이미지를 빌드할 수 있다.     
그것을 빌드 타임 인수로 할 수 있다. 인수는 Dockerfile 내에 어느 곳에나 추가할 수 있다.

ARG 라는 인수에 이름을 지정하기만 하면 된다. 지정한 인수는 Dockerfile 내에서만 사용할 수 있다.
```dockerfile
ARG DEFAULT_PORT=80
#...
```

게다가 Dockerfile 의 모든 명령에 사용할 수 있는 것은 아니다. 예를 들면 CMD 명령은 컨테이너가 실행될 때 실행되는 런타임 명령이기 때문에 사용할 수 없다.
하지만 다른 모든 명령에서는 ARG 를 사용할 수 있다.

도커에서 인수 또는 환경 변수를 참조하고 있음을 알리기 위해서 ```$``` 기호를 사용한다.

```dockerfile
ARG DEFAULT_PORT=80
# ...
ENV PORT $DEFAULT_PORT
```
동적 환경 변수의 디폴트 값으로 설정된다.

이미지를 빌드할 때 명령으로도 설정이 가능하다. ```--build-arg``` 를 추가하고 ```키=값``` 형태로 하면 된다.
```
$ docker build ... --build-arg DEFAULT_PORT=8000
```

# 모듈 요약
볼륨은 특히 컨테이너 제거 후에도 살아남아야 하는 데이터와 함께 데이터를 저장하는데 도움이 된다.
그리고 바인드 마운트는 컨테이너와 직접적인 상호작용을 한다.

볼륨은 컨테이너 내부의 매핑된 경로에 기록된 모든 내용 호스트 머신에도 저장된다.
이 데이터는 컨테이너가 제거된 경우에도 유지된다.

Named Volume 은 컨테이너가 제거되 살아남기에 유용하다. 이러한 볼륨은 데이터를 영구적으로 저장하려는 경우에 필요하다.

Anonymous Volume 은 컨테이너에 연결되며 컨테이너 제거 시 함께 제거된다. 영구 데이터가 아닌 임시 데이터를 저장하는데 유용하다.

바인드 마운트를 사용하면 호스트 머신의 로컬 폴더를 매핑할 수 있다. Named Volume 과 비슷하지만 데이터가 미러링되는 호스트 머신의 경로를 알고 있고 실제로
그 경로를 사용하여 데이터를 컨테이너에 전달하여 호스트 머신에서 그 데이터를 변경할 수 있어 컨테이너에 항상 최신의 데이터를 제공한다는 장점이 있다.

이미지와 컨테이너를 좀 더 동적이고 구성 가능하게 만들 수 있는 빌드 인수와 런타임 환경 변수가 있다.
이미지를 빌드하거나 컨테이너를 실행 시에 외부에서 특정 데이터를 전달할 수 있다.
